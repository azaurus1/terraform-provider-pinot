package provider

import (
	"context"
	"fmt"

	goPinotAPI "github.com/azaurus1/go-pinot-api"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &tablesDataSource{}
	_ datasource.DataSourceWithConfigure = &tablesDataSource{}
)

// NewUsersDataSource is a helper function to simplify the provider implementation.
func NewTablesDataSource() datasource.DataSource {
	return &tablesDataSource{}
}

// usersDataSource is the data source implementation.
type tablesDataSource struct {
	client *goPinotAPI.PinotAPIClient
}

type tablesDataSourceModel struct {
	Tables []tablesModel `tfsdk:"tables"`
}

// type TableSegmentsConfig struct {
// 	TimeType                  types.String `tfsdk:"time_type"`
// 	Replication               types.String `tfsdk:"replication"`
// 	TimeColumnName            types.String `tfsdk:"time_column_name"`
// 	SegmentAssignmentStrategy types.String `tfsdk:"segment_assignment_strategy"`
// 	SegmentPushType           types.String `tfsdk:"segment_push_type"`
// 	MinimizeDataMovement      types.Bool   `tfsdk:"minimize_data_movement"`
// }

// type TableTenant struct {
// 	Broker types.String `tfsdk:"broker"`
// 	Server types.String `tfsdk:"server"`
// }

// type StarTreeIndexConfig struct {
// 	DimensionsSplitOrder              []types.String `tfsdk:"dimensions_split_order"`
// 	SkipStarNodeCreationForDimensions []types.String `tfsdk:"skip_star_node_creation_for_dimensions"`
// 	FunctionColumnPairs               []types.String `tfsdk:"function_column_pairs"`
// 	MaxLeafRecords                    types.Int64    `tfsdk:"max_leaf_records"`
// }

// type TierOverwrite struct {
// 	StarTreeIndexConfigs []StarTreeIndexConfig `tfsdk:"star_tree_index_configs"`
// }

// type TierOverwrites struct {
// 	HotTier  TierOverwrite `tfsdk:"hot_tier"`
// 	ColdTier TierOverwrite `tfsdk:"cold_tier"`
// }

// type TableIndexConfig struct {
// 	EnableDefaultStarTree                      types.Bool            `tfsdk:"enable_default_star_tree"`
// 	StarTreeIndexConfigs                       []StarTreeIndexConfig `tfsdk:"star_tree_index_configs"`
// 	TierOverwrites                             types.String          `tfsdk:"tier_overwrites"`
// 	EnableDynamicStarTreeCreation              types.Bool            `tfsdk:"enable_dynamic_star_tree_creation"`
// 	AggregateMetrics                           types.Bool            `tfsdk:"aggregate_metrics"`
// 	NullHandlingEnabled                        types.Bool            `tfsdk:"null_handling_enabled"`
// 	OptimizeDictionary                         types.Bool            `tfsdk:"optimize_dictionary"`
// 	OptimizeDictionaryForMetrics               types.Bool            `tfsdk:"optimize_dictionary_for_metrics"`
// 	NoDictionarySizeRatioThreshold             types.Float64         `tfsdk:"no_dictionary_size_ratio_threshold"`
// 	RangeIndexVersion                          types.Int64           `tfsdk:"range_index_version"`
// 	AutoGeneratedInvertedIndex                 types.Bool            `tfsdk:"auto_generated_inverted_index"`
// 	CreateInvertedIndexDuringSegmentGeneration types.Bool            `tfsdk:"create_inverted_index_during_segment_generation"`
// 	LoadMode                                   types.String          `tfsdk:"load_mode"`
// 	StreamConfigs                              types.String          `tfsdk:"stream_configs"`
// }

// type TableMetadata struct {
// 	CustomConfigs map[string]types.String `tfsdk:"custom_configs"`
// }

// type TimestampConfig struct {
// 	Granulatities []types.String `tfsdk:"granularities"`
// }

// type FieldIndexInverted struct {
// 	Enabled types.String `tfsdk:"enabled"`
// }

// type FieldIndexes struct {
// 	Inverted FieldIndexInverted `tfsdk:"inverted"`
// }

// type FieldConfig struct {
// 	Name            types.String    `tfsdk:"name"`
// 	EncodingType    types.String    `tfsdk:"encoding_type"`
// 	IndexType       types.String    `tfsdk:"index_type"`
// 	IndexTypes      []types.String  `tfsdk:"index_types"`
// 	TimestampConfig TimestampConfig `tfsdk:"timestamp_config"`
// 	Indexes         FieldIndexes    `tfsdk:"indexes"`
// }

// type TransformConfig struct {
// 	ColumnName        types.String `tfsdk:"column_name"`
// 	TransformFunction types.String `tfsdk:"transform_function"`
// }

// type TableIngestionConfig struct {
// 	SegmentTimeValueCheckType types.String      `tfsdk:"segment_time_value_check_type"`
// 	TransformConfigs          []TransformConfig `tfsdk:"transform_configs"`
// 	ContinueOnError           types.Bool        `tfsdk:"continue_on_error"`
// 	RowTimeValueCheck         types.Bool        `tfsdk:"row_time_value_check"`
// }

// type TierConfig struct {
// 	Name                types.String `tfsdk:"name"`
// 	SegmentSelectorType types.String `tfsdk:"segment_selector_type"`
// 	SegmentAge          types.String `tfsdk:"segment_age"`
// 	StorageType         types.String `tfsdk:"storage_type"`
// 	ServerTag           types.String `tfsdk:"server_tag"`
// }

// Everything Above here set as JsonTypes?
// And then when we are setting the state we use jsonTypes.NewExactValue?

type tablesModel struct {
	TableName        types.String `tfsdk:"table_name"`
	TableType        types.String `tfsdk:"table_type"`
	SegmentsConfig   types.String `tfsdk:"segments_config"`
	Tenants          types.String `tfsdk:"tenants"`
	TableIndexConfig types.String `tfsdk:"table_index_config"`
	Metadata         types.String `tfsdk:"metadata"`
	FieldConfigList  types.String `tfsdk:"field_config_list"`
	IngestionConfig  types.String `tfsdk:"ingestion_config"`
	TierConfigs      types.String `tfsdk:"tier_configs"`
	IsDimTable       types.Bool   `tfsdk:"is_dim_table"`
}

// Configure adds the provider configured client to the data source.
func (d *tablesDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*goPinotAPI.PinotAPIClient)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *goPinotAPI.PinotAPIClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	d.client = client
}

// Metadata returns the data source type name.
func (d *tablesDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tables"
}

// Schema defines the schema for the data source.
func (d *tablesDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"tables": schema.ListNestedAttribute{
				Description: "The list of tables.",
				Computed:    true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"table_name": schema.StringAttribute{
							Description: "The name of the table.",
							Computed:    true,
						},
						"table_type": schema.StringAttribute{
							Description: "The type of the table.",
							Computed:    true,
						},
						"segments_config": schema.ListNestedAttribute{
							Description: "The segments configuration of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"time_type": schema.StringAttribute{
										Description: "The time type of the table.",
										Computed:    true,
									},
									"replication": schema.StringAttribute{
										Description: "The replication of the table.",
										Computed:    true,
									},
									"schema_name": schema.StringAttribute{
										Description: "The name of the used schema for table",
										Computed:    true,
									},
									"time_column_name": schema.StringAttribute{
										Description: "The time column name of the table.",
										Computed:    true,
									},
									"segment_assignment_strategy": schema.StringAttribute{
										Description: "The segment assignment strategy of the table.",
										Computed:    true,
									},
									"segment_push_type": schema.StringAttribute{
										Description: "The segment push type of the table.",
										Computed:    true,
									},
									"minimize_data_movement": schema.BoolAttribute{
										Description: "The minimize data movement of the table.",
										Computed:    true,
									},
								},
							},
						},
						"tenants": schema.ListNestedAttribute{
							Description: "The tenants of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"broker": schema.StringAttribute{
										Description: "The broker of the table.",
										Computed:    true,
									},
									"server": schema.StringAttribute{
										Description: "The server of the table.",
										Computed:    true,
									},
								},
							},
						},
						"table_index_config": schema.ListNestedAttribute{
							Description: "The index configuration of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"enable_default_star_tree": schema.BoolAttribute{
										Description: "The enable default star tree of the table.",
										Computed:    true,
									},
									"star_tree_index_configs": schema.ListNestedAttribute{
										Description: "The list of star tree index configurations.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"dimensions_split_order": schema.ListAttribute{
													Description: "The list of dimensions split order.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"skip_star_node_creation_for_dimensions": schema.ListAttribute{
													Description: "The list of skip star node creation for dimensions.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"function_column_pairs": schema.ListAttribute{
													Description: "The list of function column pairs.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"max_leaf_records": schema.Int64Attribute{
													Description: "The max leaf records.",
													Computed:    true,
												},
											},
										},
									},
									"tier_overwrites": schema.ListNestedAttribute{
										Description: "The tier overwrites of the table.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"hot_tier": schema.ListNestedAttribute{
													Description: "The hot tier of the table.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"star_tree_index_configs": schema.ListNestedAttribute{
																Description: "The list of star tree index configurations.",
																Computed:    true,
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"dimensions_split_order": schema.ListAttribute{
																			Description: "The list of dimensions split order.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"skip_star_node_creation_for_dimensions": schema.ListAttribute{
																			Description: "The list of skip star node creation for dimensions.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"function_column_pairs": schema.ListAttribute{
																			Description: "The list of function column pairs.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"max_leaf_records": schema.Int64Attribute{
																			Description: "The max leaf records.",
																			Computed:    true,
																		},
																	},
																},
															},
														},
													},
												},
												"cold_tier": schema.ListNestedAttribute{
													Description: "The cold tier of the table.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"star_tree_index_configs": schema.ListNestedAttribute{
																Description: "The list of star tree index configurations.",
																Computed:    true,
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"dimensions_split_order": schema.ListAttribute{
																			Description: "The list of dimensions split order.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"skip_star_node_creation_for_dimensions": schema.ListAttribute{
																			Description: "The list of skip star node creation for dimensions.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"function_column_pairs": schema.ListAttribute{
																			Description: "The list of function column pairs.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"max_leaf_records": schema.Int64Attribute{
																			Description: "The max leaf records.",
																			Computed:    true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"enable_dynamic_star_tree_creation": schema.BoolAttribute{
										Description: "The enable dynamic star tree creation of the table.",
										Computed:    true,
									},
									"aggregate_metrics": schema.BoolAttribute{
										Description: "The aggregate metrics of the table.",
										Computed:    true,
									},
									"null_handling_enabled": schema.BoolAttribute{
										Description: "The null handling enabled of the table.",
										Computed:    true,
									},
									"optimize_dictionary": schema.BoolAttribute{
										Description: "The optimize dictionary of the table.",
										Computed:    true,
									},
									"optimize_dictionary_for_metrics": schema.BoolAttribute{
										Description: "The optimize dictionary for metrics of the table.",
										Computed:    true,
									},
									"no_dictionary_size_ratio_threshold": schema.Float64Attribute{
										Description: "The no dictionary size ratio threshold.",
										Computed:    true,
									},
									"range_index_version": schema.Int64Attribute{
										Description: "The range index version.",
										Computed:    true,
									},
									"auto_generated_inverted_index": schema.BoolAttribute{
										Description: "The auto generated inverted index of the table.",
										Computed:    true,
									},
									"create_inverted_index_during_segment_generation": schema.BoolAttribute{
										Description: "The create inverted index during segment generation of the table.",
										Computed:    true,
									},
									"load_mode": schema.StringAttribute{
										Description: "The load mode of the table.",
										Computed:    true,
									},
									"stream_configs": schema.MapAttribute{
										Description: "The stream configs of the table.",
										Computed:    true,
										ElementType: types.StringType,
									},
								},
							},
						},
						"metadata": schema.ListNestedAttribute{
							Description: "The metadata of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"custom_configs": schema.MapAttribute{
										Description: "The custom configs of the table.",
										Computed:    true,
										ElementType: types.StringType,
									},
								},
							},
						},
						"field_config_list": schema.ListNestedAttribute{
							Description: "The list of field configurations.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Description: "The name of the field.",
										Computed:    true,
									},
									"encoding_type": schema.StringAttribute{
										Description: "The encoding type of the field.",
										Computed:    true,
									},
									"index_type": schema.StringAttribute{
										Description: "The index type of the field.",
										Computed:    true,
									},
									"index_types": schema.ListAttribute{
										Description: "The list of index types.",
										Computed:    true,
										ElementType: types.StringType,
									},
									"timestamp_config": schema.ListNestedAttribute{
										Description: "The timestamp configuration of the field.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"granularities": schema.ListAttribute{
													Description: "The list of granularities.",
													Computed:    true,
													ElementType: types.StringType,
												},
											},
										},
									},
									"indexes": schema.ListNestedAttribute{
										Description: "The indexes of the field.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"inverted": schema.ListNestedAttribute{
													Description: "The inverted index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"enabled": schema.StringAttribute{
																Description: "The enabled of the inverted index.",
																Computed:    true,
															},
														},
													},
												},
												"bloom": schema.ListNestedAttribute{
													Description: "The bloom index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"fpp": schema.StringAttribute{
																Description: "The false positive probability of the bloom index.",
																Computed:    true,
															},
															"max_size_in_bytes": schema.StringAttribute{
																Description: "The maximum size in bytes of the bloom index.",
																Computed:    true,
															},
															"load_on_heap": schema.StringAttribute{
																Description: "Whether to load bloom index on heap.",
																Computed:    true,
															},
														},
													},
												},
												"forward": schema.ListNestedAttribute{
													Description: "The forward index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"compression_codec": schema.StringAttribute{
																Description: "The compression codec of the forward index.",
																Computed:    true,
															},
															"derive_num_docs_per_chunk": schema.StringAttribute{
																Description: "The number of docs per chunk for the forward index.",
																Computed:    true,
															},
															"raw_index_writer_version": schema.StringAttribute{
																Description: "The raw index writer version of the forward index.",
																Computed:    true,
															},
														},
													},
												},
												"dictionary": schema.ListNestedAttribute{
													Description: "The dictionary index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"disabled": schema.BoolAttribute{
																Description: "Whether the dictionary index is disabled.",
																Computed:    true,
															},
														},
													},
												},
												"fst": schema.ListNestedAttribute{
													Description: "The FST index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"enabled": schema.BoolAttribute{
																Description: "Whether the FST index is enabled.",
																Computed:    true,
															},
														},
													},
												},
												"h3": schema.ListNestedAttribute{
													Description: "The H3 index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"resolutions": schema.ListAttribute{
																Description: "The resolutions of the H3 index.",
																Computed:    true,
																ElementType: types.Int64Type,
															},
														},
													},
												},
												"json": schema.ListNestedAttribute{
													Description: "The JSON index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"max_levels": schema.StringAttribute{
																Description: "The maximum levels of the JSON index.",
																Computed:    true,
															},
															"exclude_array": schema.BoolAttribute{
																Description: "Whether to exclude arrays in the JSON index.",
																Computed:    true,
															},
															"disable_cross_array_unnest": schema.BoolAttribute{
																Description: "Whether to disable cross array unnest in the JSON index.",
																Computed:    true,
															},
															"include_paths": schema.StringAttribute{
																Description: "The include paths of the JSON index.",
																Computed:    true,
															},
															"exclude_paths": schema.StringAttribute{
																Description: "The exclude paths of the JSON index.",
																Computed:    true,
															},
															"exclude_fields": schema.StringAttribute{
																Description: "The exclude fields of the JSON index.",
																Computed:    true,
															},
															"index_paths": schema.StringAttribute{
																Description: "The index paths of the JSON index.",
																Computed:    true,
															},
														},
													},
												},
												"range": schema.ListNestedAttribute{
													Description: "The range index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"enabled": schema.BoolAttribute{
																Description: "Whether the range index is enabled.",
																Computed:    true,
															},
														},
													},
												},
												"text": schema.ListNestedAttribute{
													Description: "The text index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"stop_word_include": schema.ListAttribute{
																Description: "The stop words to include in the text index.",
																Computed:    true,
																ElementType: types.StringType,
															},
															"stop_word_exclude": schema.ListAttribute{
																Description: "The stop words to exclude from the text index.",
																Computed:    true,
																ElementType: types.StringType,
															},
														},
													},
												},
												"vector": schema.ListNestedAttribute{
													Description: "The vector index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"vector_index_type": schema.StringAttribute{
																Description: "The vector index type.",
																Computed:    true,
															},
															"vector_dimension": schema.StringAttribute{
																Description: "The vector dimension.",
																Computed:    true,
															},
															"vector_distance_function": schema.StringAttribute{
																Description: "The vector distance function.",
																Computed:    true,
															},
															"version": schema.StringAttribute{
																Description: "The version of the vector index.",
																Computed:    true,
															},
														},
													},
												},
												"timestamp": schema.ListNestedAttribute{
													Description: "The timestamp index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"enabled": schema.BoolAttribute{
																Description: "Whether the timestamp index is enabled.",
																Computed:    true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"ingestion_config": schema.ListNestedAttribute{
							Description: "The ingestion configuration of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"segment_time_value_check_type": schema.StringAttribute{
										Description: "The segment time value check type.",
										Computed:    true,
									},
									"transform_configs": schema.ListNestedAttribute{
										Description: "The list of transform configurations.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"column_name": schema.StringAttribute{
													Description: "The name of the column.",
													Computed:    true,
												},
												"transform_function": schema.StringAttribute{
													Description: "The transform function.",
													Computed:    true,
												},
											},
										},
									},
									"continue_on_error": schema.BoolAttribute{
										Description: "The continue on error.",
										Computed:    true,
									},
									"row_time_value_check": schema.BoolAttribute{
										Description: "The row time value check.",
										Computed:    true,
									},
								},
							},
						},
						"tier_configs": schema.ListNestedAttribute{
							Description: "The list of tier configurations.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Description: "The name of the tier.",
										Computed:    true,
									},
									"segment_selector_type": schema.StringAttribute{
										Description: "The segment selector type.",
										Computed:    true,
									},
									"segment_age": schema.StringAttribute{
										Description: "The segment age.",
										Computed:    true,
									},
									"storage_type": schema.StringAttribute{
										Description: "The storage type.",
										Computed:    true,
									},
									"server_tag": schema.StringAttribute{
										Description: "The server tag.",
										Computed:    true,
									},
								},
							},
						},
						"is_dim_table": schema.BoolAttribute{
							Description: "The is dim table.",
							Computed:    true,
						},
					},
				},
			},
		},
	}
}

// Read refreshes the Terraform state with the latest data.
func (d *tablesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state tablesDataSourceModel

	// tablesResp, err := d.client.GetTables()
	// if err != nil {
	// 	resp.Diagnostics.AddError("Failed to get tables", fmt.Sprintf("Failed to get tables: %s", err))
	// 	return
	// }

	// for _, tableName := range tablesResp.Tables {
	// 	tableResp, err := d.client.GetTable(tableName)
	// 	if err != nil {
	// 		resp.Diagnostics.AddError("Failed to get table", fmt.Sprintf("Failed to get table: %s", err))
	// 		return
	// 	}

	// 	// tableOffline := tablesModel{
	// 	// 	TableName:        types.StringValue(tableResp.OFFLINE.TableName),
	// 	// 	TableType:        types.StringValue(tableResp.OFFLINE.TableType),
	// 	// 	SegmentsConfig:   types.StringValue(tableResp.OFFLINE.SegmentsConfig),
	// 	// 	Tenants:          types.StringValue(tableResp.OFFLINE.Tenants),
	// 	// 	TableIndexConfig: types.StringValue(tableResp.OFFLINE.TableIndexConfig),
	// 	// 	Metadata:         types.StringValue(tableResp.OFFLINE.Metadata),
	// 	// 	FieldConfigList:  types.StringValue(tableResp.OFFLINE.FieldConfigList),
	// 	// 	IngestionConfig:  types.StringValue(tableResp.OFFLINE.IngestionConfig),
	// 	// 	TierConfigs:      types.StringValue(tableResp.OFFLINE.TierConfigs),
	// 	// 	IsDimTable:       types.BoolValue(tableResp.OFFLINE.IsDimTable),
	// 	// }

	// 	// tableRealtime := tablesModel{
	// 	// 	TableName:        tableResp.OFFLINE.TableName,
	// 	// 	TableType:        tableResp.OFFLINE.TableType,
	// 	// 	SegmentsConfig:   tableResp.OFFLINE.SegmentsConfig,
	// 	// 	Tenants:          tableResp.OFFLINE.Tenants,
	// 	// 	TableIndexConfig: tableResp.OFFLINE.TableIndexConfig,
	// 	// 	Metadata:         tableResp.OFFLINE.Metadata,
	// 	// 	FieldConfigList:  tableResp.OFFLINE.FieldConfigList,
	// 	// 	IngestionConfig:  tableResp.OFFLINE.IngestionConfig,
	// 	// 	TierConfigs:      tableResp.OFFLINE.TierConfigs,
	// 	// 	IsDimTable:       tableResp.OFFLINE.IsDimTable,
	// 	// }

	// 	// state.Tables = append(state.Tables, tableRealtime)

	// }

	diags := resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

}

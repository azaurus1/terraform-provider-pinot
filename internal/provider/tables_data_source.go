package provider

import (
	"context"
	"fmt"

	goPinotAPI "github.com/azaurus1/go-pinot-api"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
	_ datasource.DataSource              = &tablesDataSource{}
	_ datasource.DataSourceWithConfigure = &tablesDataSource{}
)

// NewUsersDataSource is a helper function to simplify the provider implementation.
func NewTablesDataSource() datasource.DataSource {
	return &tablesDataSource{}
}

// usersDataSource is the data source implementation.
type tablesDataSource struct {
	client *goPinotAPI.PinotAPIClient
}

type tablesDataSourceModel struct {
	Tables []tablesModel `tfsdk:"tables"`
}

type TableSegmentsConfig struct {
	TimeType                  types.String `tfsdk:"time_type"`
	Replication               types.String `tfsdk:"replication"`
	TimeColumnName            types.String `tfsdk:"time_column_name"`
	SegmentAssignmentStrategy types.String `tfsdk:"segment_assignment_strategy"`
	SegmentPushType           types.String `tfsdk:"segment_push_type"`
	MinimizeDataMovement      types.Bool   `tfsdk:"minimize_data_movement"`
}

type TableTenant struct {
	Broker types.String `tfsdk:"broker"`
	Server types.String `tfsdk:"server"`
}

type StarTreeIndexConfig struct {
	DimensionsSplitOrder              []types.String `tfsdk:"dimensions_split_order"`
	SkipStarNodeCreationForDimensions []types.String `tfsdk:"skip_star_node_creation_for_dimensions"`
	FunctionColumnPairs               []types.String `tfsdk:"function_column_pairs"`
	MaxLeafRecords                    types.Int64    `tfsdk:"max_leaf_records"`
}

type TierOverwrite struct {
	StarTreeIndexConfigs []StarTreeIndexConfig `tfsdk:"star_tree_index_configs"`
}

type TierOverwrites struct {
	HotTier  TierOverwrite `tfsdk:"hot_tier"`
	ColdTier TierOverwrite `tfsdk:"cold_tier"`
}

type TableIndexConfig struct {
	EnableDefaultStarTree                      types.Bool              `tfsdk:"enable_default_star_tree"`
	StarTreeIndexConfigs                       []StarTreeIndexConfig   `tfsdk:"star_tree_index_configs"`
	TierOverwrites                             TierOverwrites          `tfsdk:"tier_overwrites"`
	EnableDynamicStarTreeCreation              types.Bool              `tfsdk:"enable_dynamic_star_tree_creation"`
	AggregateMetrics                           types.Bool              `tfsdk:"aggregate_metrics"`
	NullHandlingEnabled                        types.Bool              `tfsdk:"null_handling_enabled"`
	OptimizeDictionary                         types.Bool              `tfsdk:"optimize_dictionary"`
	OptimizeDictionaryForMetrics               types.Bool              `tfsdk:"optimize_dictionary_for_metrics"`
	NoDictionarySizeRatioThreshold             types.Float64           `tfsdk:"no_dictionary_size_ratio_threshold"`
	RangeIndexVersion                          types.Int64             `tfsdk:"range_index_version"`
	AutoGeneratedInvertedIndex                 types.Bool              `tfsdk:"auto_generated_inverted_index"`
	CreateInvertedIndexDuringSegmentGeneration types.Bool              `tfsdk:"create_inverted_index_during_segment_generation"`
	LoadMode                                   types.String            `tfsdk:"load_mode"`
	StreamConfigs                              map[string]types.String `tfsdk:"stream_configs"`
}

type TableMetadata struct {
	CustomConfigs map[string]types.String `tfsdk:"custom_configs"`
}

type TimestampConfig struct {
	Granulatities []types.String `tfsdk:"granularities"`
}

type FieldIndexInverted struct {
	Enabled types.String `tfsdk:"enabled"`
}

type FieldIndexes struct {
	Inverted FieldIndexInverted `tfsdk:"inverted"`
}

type FieldConfig struct {
	Name            types.String    `tfsdk:"name"`
	EncodingType    types.String    `tfsdk:"encoding_type"`
	IndexType       types.String    `tfsdk:"index_type"`
	IndexTypes      []types.String  `tfsdk:"index_types"`
	TimestampConfig TimestampConfig `tfsdk:"timestamp_config"`
	Indexes         FieldIndexes    `tfsdk:"indexes"`
}

type TransformConfig struct {
	ColumnName        types.String `tfsdk:"column_name"`
	TransformFunction types.String `tfsdk:"transform_function"`
}

type TableIngestionConfig struct {
	SegmentTimeValueCheckType types.String      `tfsdk:"segment_time_value_check_type"`
	TransformConfigs          []TransformConfig `tfsdk:"transform_configs"`
	ContinueOnError           types.Bool        `tfsdk:"continue_on_error"`
	RowTimeValueCheck         types.Bool        `tfsdk:"row_time_value_check"`
}

type TierConfig struct {
	Name                types.String `tfsdk:"name"`
	SegmentSelectorType types.String `tfsdk:"segment_selector_type"`
	SegmentAge          types.String `tfsdk:"segment_age"`
	StorageType         types.String `tfsdk:"storage_type"`
	ServerTag           types.String `tfsdk:"server_tag"`
}

// Everything Above here set as JsonTypes?
// And then when we are setting the state we use jsonTypes.NewExactValue?

type tablesModel struct {
	TableName        types.String         `tfsdk:"table_name"`
	TableType        types.String         `tfsdk:"table_type"`
	SegmentsConfig   TableSegmentsConfig  `tfsdk:"segments_config"`
	Tenants          TableTenant          `tfsdk:"tenants"`
	TableIndexConfig TableIndexConfig     `tfsdk:"table_index_config"`
	Metadata         TableMetadata        `tfsdk:"metadata"`
	FieldConfigList  []FieldConfig        `tfsdk:"field_config_list"`
	IngestionConfig  TableIngestionConfig `tfsdk:"ingestion_config"`
	TierConfigs      []TierConfig         `tfsdk:"tier_configs"`
	IsDimTable       types.Bool           `tfsdk:"is_dim_table"`
}

// Configure adds the provider configured client to the data source.
func (d *tablesDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*goPinotAPI.PinotAPIClient)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *goPinotAPI.PinotAPIClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	d.client = client
}

// Metadata returns the data source type name.
func (d *tablesDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_tables"
}

// Schema defines the schema for the data source.
func (d *tablesDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"tables": schema.ListNestedAttribute{
				Description: "The list of tables.",
				Computed:    true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"table_name": schema.StringAttribute{
							Description: "The name of the table.",
							Computed:    true,
						},
						"table_type": schema.StringAttribute{
							Description: "The type of the table.",
							Computed:    true,
						},
						"segments_config": schema.ListNestedAttribute{
							Description: "The segments configuration of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"time_type": schema.StringAttribute{
										Description: "The time type of the table.",
										Computed:    true,
									},
									"replication": schema.StringAttribute{
										Description: "The replication of the table.",
										Computed:    true,
									},
									"time_column_name": schema.StringAttribute{
										Description: "The time column name of the table.",
										Computed:    true,
									},
									"segment_assignment_strategy": schema.StringAttribute{
										Description: "The segment assignment strategy of the table.",
										Computed:    true,
									},
									"segment_push_type": schema.StringAttribute{
										Description: "The segment push type of the table.",
										Computed:    true,
									},
									"minimize_data_movement": schema.BoolAttribute{
										Description: "The minimize data movement of the table.",
										Computed:    true,
									},
								},
							},
						},
						"tenants": schema.ListNestedAttribute{
							Description: "The tenants of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"broker": schema.StringAttribute{
										Description: "The broker of the table.",
										Computed:    true,
									},
									"server": schema.StringAttribute{
										Description: "The server of the table.",
										Computed:    true,
									},
								},
							},
						},
						"table_index_config": schema.ListNestedAttribute{
							Description: "The index configuration of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"enable_default_star_tree": schema.BoolAttribute{
										Description: "The enable default star tree of the table.",
										Computed:    true,
									},
									"star_tree_index_configs": schema.ListNestedAttribute{
										Description: "The list of star tree index configurations.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"dimensions_split_order": schema.ListAttribute{
													Description: "The list of dimensions split order.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"skip_star_node_creation_for_dimensions": schema.ListAttribute{
													Description: "The list of skip star node creation for dimensions.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"function_column_pairs": schema.ListAttribute{
													Description: "The list of function column pairs.",
													Computed:    true,
													ElementType: types.StringType,
												},
												"max_leaf_records": schema.Int64Attribute{
													Description: "The max leaf records.",
													Computed:    true,
												},
											},
										},
									},
									"tier_overwrites": schema.ListNestedAttribute{
										Description: "The tier overwrites of the table.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"hot_tier": schema.ListNestedAttribute{
													Description: "The hot tier of the table.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"star_tree_index_configs": schema.ListNestedAttribute{
																Description: "The list of star tree index configurations.",
																Computed:    true,
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"dimensions_split_order": schema.ListAttribute{
																			Description: "The list of dimensions split order.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"skip_star_node_creation_for_dimensions": schema.ListAttribute{
																			Description: "The list of skip star node creation for dimensions.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"function_column_pairs": schema.ListAttribute{
																			Description: "The list of function column pairs.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"max_leaf_records": schema.Int64Attribute{
																			Description: "The max leaf records.",
																			Computed:    true,
																		},
																	},
																},
															},
														},
													},
												},
												"cold_tier": schema.ListNestedAttribute{
													Description: "The cold tier of the table.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"star_tree_index_configs": schema.ListNestedAttribute{
																Description: "The list of star tree index configurations.",
																Computed:    true,
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"dimensions_split_order": schema.ListAttribute{
																			Description: "The list of dimensions split order.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"skip_star_node_creation_for_dimensions": schema.ListAttribute{
																			Description: "The list of skip star node creation for dimensions.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"function_column_pairs": schema.ListAttribute{
																			Description: "The list of function column pairs.",
																			Computed:    true,
																			ElementType: types.StringType,
																		},
																		"max_leaf_records": schema.Int64Attribute{
																			Description: "The max leaf records.",
																			Computed:    true,
																		},
																	},
																},
															},
														},
													},
												},
											},
										},
									},
									"enable_dynamic_star_tree_creation": schema.BoolAttribute{
										Description: "The enable dynamic star tree creation of the table.",
										Computed:    true,
									},
									"aggregate_metrics": schema.BoolAttribute{
										Description: "The aggregate metrics of the table.",
										Computed:    true,
									},
									"null_handling_enabled": schema.BoolAttribute{
										Description: "The null handling enabled of the table.",
										Computed:    true,
									},
									"optimize_dictionary": schema.BoolAttribute{
										Description: "The optimize dictionary of the table.",
										Computed:    true,
									},
									"optimize_dictionary_for_metrics": schema.BoolAttribute{
										Description: "The optimize dictionary for metrics of the table.",
										Computed:    true,
									},
									"no_dictionary_size_ratio_threshold": schema.Float64Attribute{
										Description: "The no dictionary size ratio threshold.",
										Computed:    true,
									},
									"range_index_version": schema.Int64Attribute{
										Description: "The range index version.",
										Computed:    true,
									},
									"auto_generated_inverted_index": schema.BoolAttribute{
										Description: "The auto generated inverted index of the table.",
										Computed:    true,
									},
									"create_inverted_index_during_segment_generation": schema.BoolAttribute{
										Description: "The create inverted index during segment generation of the table.",
										Computed:    true,
									},
									"load_mode": schema.StringAttribute{
										Description: "The load mode of the table.",
										Computed:    true,
									},
									"stream_configs": schema.MapAttribute{
										Description: "The stream configs of the table.",
										Computed:    true,
										ElementType: types.StringType,
									},
								},
							},
						},
						"metadata": schema.ListNestedAttribute{
							Description: "The metadata of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"custom_configs": schema.MapAttribute{
										Description: "The custom configs of the table.",
										Computed:    true,
										ElementType: types.StringType,
									},
								},
							},
						},
						"field_config_list": schema.ListNestedAttribute{
							Description: "The list of field configurations.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Description: "The name of the field.",
										Computed:    true,
									},
									"encoding_type": schema.StringAttribute{
										Description: "The encoding type of the field.",
										Computed:    true,
									},
									"index_type": schema.StringAttribute{
										Description: "The index type of the field.",
										Computed:    true,
									},
									"index_types": schema.ListAttribute{
										Description: "The list of index types.",
										Computed:    true,
										ElementType: types.StringType,
									},
									"timestamp_config": schema.ListNestedAttribute{
										Description: "The timestamp configuration of the field.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"granularities": schema.ListAttribute{
													Description: "The list of granularities.",
													Computed:    true,
													ElementType: types.StringType,
												},
											},
										},
									},
									"indexes": schema.ListNestedAttribute{
										Description: "The indexes of the field.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"inverted": schema.ListNestedAttribute{
													Description: "The inverted index of the field.",
													Computed:    true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"enabled": schema.StringAttribute{
																Description: "The enabled of the inverted index.",
																Computed:    true,
															},
														},
													},
												},
											},
										},
									},
								},
							},
						},
						"ingestion_config": schema.ListNestedAttribute{
							Description: "The ingestion configuration of the table.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"segment_time_value_check_type": schema.StringAttribute{
										Description: "The segment time value check type.",
										Computed:    true,
									},
									"transform_configs": schema.ListNestedAttribute{
										Description: "The list of transform configurations.",
										Computed:    true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"column_name": schema.StringAttribute{
													Description: "The name of the column.",
													Computed:    true,
												},
												"transform_function": schema.StringAttribute{
													Description: "The transform function.",
													Computed:    true,
												},
											},
										},
									},
									"continue_on_error": schema.BoolAttribute{
										Description: "The continue on error.",
										Computed:    true,
									},
									"row_time_value_check": schema.BoolAttribute{
										Description: "The row time value check.",
										Computed:    true,
									},
								},
							},
						},
						"tier_configs": schema.ListNestedAttribute{
							Description: "The list of tier configurations.",
							Computed:    true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Description: "The name of the tier.",
										Computed:    true,
									},
									"segment_selector_type": schema.StringAttribute{
										Description: "The segment selector type.",
										Computed:    true,
									},
									"segment_age": schema.StringAttribute{
										Description: "The segment age.",
										Computed:    true,
									},
									"storage_type": schema.StringAttribute{
										Description: "The storage type.",
										Computed:    true,
									},
									"server_tag": schema.StringAttribute{
										Description: "The server tag.",
										Computed:    true,
									},
								},
							},
						},
						"is_dim_table": schema.BoolAttribute{
							Description: "The is dim table.",
							Computed:    true,
						},
					},
				},
			},
		},
	}
}

// Read refreshes the Terraform state with the latest data.
func (d *tablesDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state tablesDataSourceModel

	tablesResp, err := d.client.GetTables()
	if err != nil {
		resp.Diagnostics.AddError("Failed to get tables", fmt.Sprintf("Failed to get tables: %s", err))
		return
	}

	for _, tableName := range tablesResp.Tables {
		tableResp, err := d.client.GetTable(tableName)
		if err != nil {
			resp.Diagnostics.AddError("Failed to get table", fmt.Sprintf("Failed to get table: %s", err))
			return
		}

		tableOffline := tablesModel{
			TableName: tableResp.OFFLINE.TableName,
			TableType: tableResp.OFFLINE.TableType,
			SegmentsConfig: TableSegmentsConfig{
				TimeType:                  tableResp.OFFLINE.SegmentsConfig.TimeType,
				Replication:               tableResp.OFFLINE.SegmentsConfig.Replication,
				TimeColumnName:            tableResp.OFFLINE.SegmentsConfig.TimeColumnName,
				SegmentAssignmentStrategy: tableResp.OFFLINE.SegmentsConfig.SegmentAssignmentStrategy,
				SegmentPushType:           tableResp.OFFLINE.SegmentsConfig.SegmentPushType,
				MinimizeDataMovement:      false,
			},
			Tenants: TableTenant{
				Broker: tableResp.OFFLINE.Tenants.Broker,
				Server: tableResp.OFFLINE.Tenants.Server,
			},
			TableIndexConfig: TableIndexConfig{
				EnableDefaultStarTree:                      tableResp.OFFLINE.TableIndexConfig.EnableDefaultStarTree,
				StarTreeIndexConfigs:                       []StarTreeIndexConfig{},
				TierOverwrites:                             TierOverwrites{},
				EnableDynamicStarTreeCreation:              tableResp.OFFLINE.TableIndexConfig.EnableDynamicStarTreeCreation,
				AggregateMetrics:                           tableResp.OFFLINE.TableIndexConfig.AggregateMetrics,
				NullHandlingEnabled:                        tableResp.OFFLINE.TableIndexConfig.NullHandlingEnabled,
				OptimizeDictionary:                         tableResp.OFFLINE.TableIndexConfig.OptimizeDictionary,
				OptimizeDictionaryForMetrics:               tableResp.OFFLINE.TableIndexConfig.OptimizeDictionaryForMetrics,
				NoDictionarySizeRatioThreshold:             tableResp.OFFLINE.TableIndexConfig.NoDictionarySizeRatioThreshold,
				RangeIndexVersion:                          tableResp.OFFLINE.TableIndexConfig.RangeIndexVersion,
				AutoGeneratedInvertedIndex:                 tableResp.OFFLINE.TableIndexConfig.AutoGeneratedInvertedIndex,
				CreateInvertedIndexDuringSegmentGeneration: tableResp.OFFLINE.TableIndexConfig.CreateInvertedIndexDuringSegmentGeneration,
				LoadMode:      tableResp.OFFLINE.TableIndexConfig.LoadMode,
				StreamConfigs: tableResp.OFFLINE.TableIndexConfig.StreamConfigs,
			},
			Metadata:        TableMetadata{},
			FieldConfigList: []FieldConfig{},
			IngestionConfig: TableIngestionConfig{},
			TierConfigs:     []TierConfig{},
			IsDimTable:      tableResp.OFFLINE.IsDimTable,
		}

		tableRealtime := tablesModel{
			TableName: types.StringValue(tableResp.REALTIME.TableName),
			TableType: types.StringValue(tableResp.REALTIME.TableType),
			SegmentsConfig: TableSegmentsConfig{
				TimeType:                  types.StringValue(tableResp.REALTIME.SegmentsConfig.TimeType),
				Replication:               types.StringValue(tableResp.REALTIME.SegmentsConfig.Replication),
				TimeColumnName:            types.StringValue(tableResp.REALTIME.SegmentsConfig.TimeColumnName),
				SegmentAssignmentStrategy: types.StringValue(tableResp.REALTIME.SegmentsConfig.SegmentAssignmentStrategy),
				SegmentPushType:           types.StringValue(tableResp.REALTIME.SegmentsConfig.SegmentPushType),
				MinimizeDataMovement:      types.BoolValue(tableResp.REALTIME.SegmentsConfig.MinimizeDataMovement),
			},
			Tenants: TableTenant{
				Broker: types.StringValue(tableResp.REALTIME.Tenants.Broker),
				Server: types.StringValue(tableResp.REALTIME.Tenants.Server),
			},
			TableIndexConfig: TableIndexConfig{
				EnableDefaultStarTree:                      types.BoolValue(tableResp.REALTIME.TableIndexConfig.EnableDefaultStarTree),
				StarTreeIndexConfigs:                       []StarTreeIndexConfig{},
				TierOverwrites:                             TierOverwrites{},
				EnableDynamicStarTreeCreation:              types.BoolValue(tableResp.REALTIME.TableIndexConfig.EnableDynamicStarTreeCreation),
				AggregateMetrics:                           types.BoolValue(tableResp.REALTIME.TableIndexConfig.AggregateMetrics),
				NullHandlingEnabled:                        types.BoolValue(tableResp.REALTIME.TableIndexConfig.NullHandlingEnabled),
				OptimizeDictionary:                         types.BoolValue(tableResp.REALTIME.TableIndexConfig.OptimizeDictionary),
				OptimizeDictionaryForMetrics:               types.BoolValue(tableResp.REALTIME.TableIndexConfig.OptimizeDictionaryForMetrics),
				NoDictionarySizeRatioThreshold:             types.Float64Value(tableResp.REALTIME.TableIndexConfig.NoDictionarySizeRatioThreshold),
				RangeIndexVersion:                          types.Int64Value(int64(tableResp.REALTIME.TableIndexConfig.RangeIndexVersion)),
				AutoGeneratedInvertedIndex:                 types.BoolValue(tableResp.REALTIME.TableIndexConfig.AutoGeneratedInvertedIndex),
				CreateInvertedIndexDuringSegmentGeneration: types.BoolValue(tableResp.REALTIME.TableIndexConfig.CreateInvertedIndexDuringSegmentGeneration),
				LoadMode: types.StringValue(tableResp.REALTIME.TableIndexConfig.LoadMode),
				// StreamConfigs: tableResp.REALTIME.TableIndexConfig.StreamConfigs,
			},
			Metadata:        TableMetadata{},
			FieldConfigList: []FieldConfig{},
			IngestionConfig: TableIngestionConfig{},
			TierConfigs:     []TierConfig{},
			IsDimTable:      types.BoolValue(tableResp.REALTIME.IsDimTable),
		}

		state.Tables = append(state.Tables, tableRealtime)

	}

	diags := resp.State.Set(ctx, &state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

}
